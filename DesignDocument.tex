\documentclass[12pt]{article}       %{amsart}

\usepackage[svgnames]{xcolor} 

\usepackage{amsmath, amsthm, ulem, graphicx, marvosym, fancyhdr, amscd, amssymb, float, enumerate}

%added as part of article format

\topmargin -.3in
\evensidemargin -.1in
\oddsidemargin -.1in
\textheight 8.5in
\textwidth 6.5in
\def\hs{\hspace{15pt}}

\newcommand*{\titleAT}{\begingroup % Create the command for including the title page in the document
\newlength{\drop} % Command for generating a specific amount of whitespace
\drop=0.1\textheight % Define the command as 10% of the total text height

\rule{\textwidth}{1pt}\par % Thick horizontal line
\vspace{2pt}\vspace{-\baselineskip} % Whitespace between lines
\rule{\textwidth}{0.4pt}\par % Thin horizontal line

\vspace{\drop} % Whitespace between the top lines and title
\centering % Center all text
\textcolor{Red}{ % Red font color
{\Huge Two-Dimensional Space Shooter Game with Roguelike Gameplay Mechanics}\\[0.5\baselineskip] % Title line 1
%{\Large with}\\[0.75\baselineskip] % Title line 2
{\Huge }} % Title line 3

\vspace{0.25\drop} % Whitespace between the title and short horizontal line
\rule{0.3\textwidth}{0.4pt}\par % Short horizontal line under the title
\vspace{\drop} % Whitespace between the thin horizontal line and the author name

{\Large \textsc{George Bateman BS CS \\* Jacob Cannon BS CS \\* Nicholas DeVoll BS CS \\* \vspace{3pt} Madison Silva BA CS}}\par % Author name

\vfill % Whitespace between the author name and publisher text

{\large \textsc{Faculty Mentor: Dr. Jorge Reyes Silveyra}}\par 

{\large \textsc{May 15th 2015}}\par

\vspace*{\drop} % Whitespace under the publisher text

\rule{\textwidth}{0.4pt}\par % Thin horizontal line
\vspace{2pt}\vspace{-\baselineskip} % Whitespace between lines
\rule{\textwidth}{1pt}\par % Thick horizontal line

\endgroup}

\setcounter{tocdepth}{2}

\begin{document}

\begin{titlepage}
\thispagestyle{empty}
\titleAT
\end{titlepage}

\newpage
\begin{titlepage}
\thispagestyle{empty}
\tableofcontents
\end{titlepage}

\begin{titlepage}
\thispagestyle{empty}
\listoffigures
\end{titlepage}

%\author{Madison Silva}\address{Pacific Lutheran University\\ Tacoma, WA 98447}%\email{silvamj@plu.edu}

\newpage

\section{Introduction} %INTRODUCTION 
\label{sec:intro}

\hs Video games have been a rapidly growing industry in the past 30 years \cite{History}. As such, there are a wide variety of genres and subgenres of games, each taking influence from and building upon successful games of the past. In some cases these games combine past elements in a way that create a new category of game. The goal of this project is to develop a game that will blend space-shooter elements from classic arcade games, such as Asteroids and Galaga, with randomized, challenging elements from more recent games such as The Binding of Isaac. These elements will include random usable items and equipment, permanent player death, and randomly generated level design. This combination will aim to provide players with new challenges that may not be available in current games. This game will be developed using Unity3D and will run in the Unity engine, which features robust tools that will allow us to manipulate nearly any element of the game quickly and with immediate feedback.

\subsection{Research}
	For the development of this project, we will develop a video game using Unity. The majority of the research time will be used to learn the functionality of Unity. Since Unity is a complete game engine and editor, the game creation process will not require the development of an engine. Other alternative engines, such as the graphics engine Ogre3D, would still require the implementation of a game engine in addition to creating the game \cite{Ogre}. Unreal Engine 4 was another considered engine, and included many features that would be useful to this project. However, many individuals have said that it is difficult for beginners to learn due to the lack of tutorials. Ultimately, we settled on Unity, since it has a wide range of tutorials to help us get started more quickly and will allow the majority of the project resources to go towards gameplay. development.

        Unity primarily uses $C\#$ as it’s scripting language. $C\#$ was created by Microsoft in 1997. It uses the .NET framework and is the most popular .NET language used today. It was influenced heavily by Java and C++, and it is intended to be friendly to the software development process so it has features such as uninitialized variable compatibility and automatic garbage collection \cite{Cadet}. Even though $C\#$ is a compiled language, Unity is still able to use $C\#$ code snippets as “scripts” because Unity is built in IDE (Monodevelop), compiles the code and packages it with game resources before runtime. This gives the games a robust set of tools, but allows the game to load and run quickly. \cite{Moles} 

	Our game strives to follow the principles set out by previous roguelike games. The term roguelike is a broad term used to describe video games that use random elements to create a replayable game that restarts the player on each subsequent playthrough. The original game that spawned this categorization was the game Rogue. Rogue was programmed at UC Santa Cruz in the 1980’s, using ASCII characters to take players on an adventure through a subterranean dungeon for the Amulet of Yendor. Once the game was released to others outside the developer, it spread rapidly throughout the college and the surrounding communities. Rogue inspired many other hits in the video game industry, including Diablo II, Faster Than Light, and The Binding of Isaac. \cite{Rogue}

	While developing non-player entities it is crucial to have an AI. Without an AI the entity becomes a stationary object and if they are an enemy that is not very exciting. One of the first step in creating a basic AI is choosing a pathfinding algorithm, so that the entity will move properly. An example of a basic but effective pathfinding algorithm is A*. Amit Patel defines A* as a combination of Dijkstra’s Algorithm and the Best-First-Search Algorithm \cite{A}. Dijkstra’s Algorithm searches all cells around the starting point moving out and searching the next farthest out cells in each direction until it finds the goal. In a game where time is valuable searching in the way would be inefficient. Best- First-Search(BFS) is faster because it searches only in the direction of the goal. This algorithm is not efficient for games because if there is an obstacle then the path that BFS takes can become inefficient. A* searches all vertices by favoring the ones in the direction of the goal, this helps it be more efficient like BFS but avoid obstacles more like Dijkstra’s. \cite{A}

	Finally, procedurally generated content will be used in order to build satisfying and challenging areas for the player. Procedural content generation is the process of designing an algorithm that can generate content at runtime. This fits in well with this project. With a relatively small number of inputs, the game can generate numerous different levels where the enemies encountered are found in different combinations. It also embodies the core idea of a roguelike game, changing the game every playthrough to challenge the player differently. There are a multitude of content generation algorithms, one of the common ones being Perlin noise, which actually refers to two algorithms created by Ken Perlin. These algorithms use a sum of different functions with varying amplitudes and frequencies in order to generate what is called a noise function. It is this function that is used to define different points of intensity. As it pertains to this project, these functions could be used to generate nebulae or star maps, giving a different visual experience to our player every time. \cite{PCG}


\section{Gameplay} %GAMEPLAY
\label{sec:Gameplay}

{\bf First Minute}: The player enters the game with their chosen ship, and can immediately start exploring the area in which they spawn. They will see the controls of the game described on the field, introducing new players to the game. After discovering how to control their ship, players will be able to leave the starting area in a single direction, leading them to the first area of the game. In this first area, enemies will be created at the other side of the field. The player must defeat these enemies to clear the field and move on. As the player moves about the field, the enemies start reacting, moving towards the player to defeat him. When battle resolves, any dropped items and currency are picked up by the player, and they are given a choice where to go next.

{\bf Gameflow:}


{\bf Victory conditions}: The player will achieve victory by completing each area that is generated without dying. The game is planned to culminate with a boss fight, and defeating this boss will trigger victory and end the game.

\section{Requirements} %REQUIREMENTS
\label{sec:Requirements}

\hs The following use cases and diagrams describe how the game will be implemented in the Unity game engine. While Unity is set up to handle the View portion and some of the Controller portion of the MVC architecture, we will have to supply part of the Controller and the Model portion in order to deliver our game.

\subsection{Use Case Scenarios} 
%%%
Scenario Name: {\bf PlayerDeath} \\
Participating Actor Instances:        \hspace{46pt} {\bf Player: PlayerEntity

					          \hspace{2.6 in}   Damager: DamageEntity 

					          \hspace{2.6in}    Heath: PlayerHP

						\hspace{2.6in}   Shield: PlayerShield} \vspace{10pt}  \\ 
Flow of Events: 
\begin{enumerate} 
\item {\bf Player }collides with {\bf DamageEntity}.
       \item {\bf PlayerShield} decreases based on DamageEntity. 
       \item {\bf PlayerHP} decreases based on DamageEntity and Shield. 
                \begin{enumerate}[a.]
                 \item {\bf PlayerHP} is greater than zero, continue as normal.
                 \item{\bf PlayerHP} is less than or equal to zero, {\bf Player} dies.
                      \begin{enumerate}[i.]
                	\item {\bf Player} is deleted.
                	\item Explosion animation spawned in place of {\bf Player}.
		\item An end game menu prompts {\bf Player} to either play again or return to main menu.
		 \end{enumerate}
                \end{enumerate}
\end{enumerate}

%%%
\begin{center} \line(1,0){350} \end{center}
Scenario Name: {\bf GameComplete} \\
Participating Actor Instances:        \hspace{46pt} {\bf Player: PlayerEntity

					          \hspace{2.6 in}   Boss: HostileEntity 

                                                      \hspace{2.6 in}   Bullet: Projectile} \vspace{10pt}  \\ 
Flow of Events: 
\begin{enumerate} 
\item {\bf Boss} is destroyed by a {\bf Bullet} shot by the {\bf Player}.
\item {\bf Boss} will enter an animation where it explodes.
\item {\bf Player} enters  a five second grace period where they must survive.
	\begin{enumerate} [a.]
	\item {\bf Player} does not survive the grace period and dies, restarting the game.
	\item {\bf Player} survives the grace period.
		\begin{enumerate} [i.]
		\item {\bf Player} is treated to a victory screen.
		\item {\bf Player} is given the option to play again or quit.
		\end{enumerate}
	\end{enumerate}
\end{enumerate}

%%%
\begin{center} \line(1,0){350} \end{center}
Scenario Name: {\bf LeavingFieldOfPlay} \\
Participating Actor Instances:        \hspace{46pt} {\bf Player: PlayerEntity

					          \hspace{2.6 in}  Projectile: PlayerKiller}  \vspace{10pt}  \\ 
Flow of Events: 
\begin{enumerate} 
\item {\bf Player} leaves the field of play.
\item Warning alarm sounds, warning flashes on screen.
      \begin{enumerate}[a.]
       \item {\bf Player} chooses to turn around and return to field of play, everything returns to normal.
       \item {\bf Player} advances farther out of the field of play.
                \begin{enumerate}[i.]
                \item {\bf PlayerKiller} kills {\bf Player}.
                \end{enumerate}
        \end{enumerate}
\end{enumerate}

%%%
\begin{center} \line(1,0){350} \end{center}
Scenario Name: {\bf SpawnEnemyWave} \\
Participating Actor Instances:        \hspace{46pt} {\bf Enemy: EnemyEntity

						\hspace{2.6 in} Wave: float

					          \hspace{2.6 in}   GC: GameController}  \vspace{10pt}  \\ 
Flow of Events: 
\begin{enumerate} 
\item {\bf GC} waits a set amount of time before attempting to spawn a wave.
\item The allotted amount of time has passed.
	\begin{enumerate} [a.]
	\item {\bf Wave} is not equal to the number of total waves.
		\begin{enumerate} [i.]
		\item Enemies are spawned in according to how many waves the player has defeated.
		\end{enumerate}
	\item {\bf Wave} is equal to the number of total waves.
		\begin{enumerate} [i.]
		\item The boss is spawned in and the player must fight them to win.
		\end{enumerate}
	\end{enumerate}
\end{enumerate}

%%%
\begin{center} \line(1,0){350} \end{center}
Scenario Name: {\bf MoveAndShoot} \\
Participating Actor Instances:        \hspace{46pt} {\bf Player: PlayerEntity

					          \hspace{2.6 in}   Bullet:Projectile}  \vspace{10pt}  \\ 
Flow of Events: 
\begin{enumerate} 
\item {\bf Player} presses a movement button, which defaults to the WASD keys, while simultaneously pressing a fire button, which default to the $ \uparrow \downarrow \leftarrow \to $ arrow keys.
\item {\bf Player} moves in the direction of the movement button pressed, while {\bf Bullet} is fired in the direction of the fire button pressed.
\item {\bf Player} continues moving in the way of the first directional input until an additional input is received, at which time {\bf Player} will begin to move in the way of the second directional input. 
\item {\bf Bullet} travels in the direction it was initially shot without the possibility of changing direction.
\end{enumerate}

%%%
\begin{center} \line(1,0){350} \end{center}
Scenario Name: {\bf SpawnAsteroids} \\
Participating Actor Instances:        \hspace{46pt} {\bf Enemy: EnemyEntity

						\hspace{2.6 in} Asteroid: AsteroidEntity

						\hspace{2.6 in}  GC: GameController}  \vspace{10pt}  \\ 
Flow of Events: 
\begin{enumerate} 
\item {\bf GC} performs a check to see if an asteroid will spawn.
\item The check fails.
	\begin{enumerate} [a.]
	\item Nothing occurs, and {\bf GC} waits before attempting to spawn another.
	\end{enumerate}
\item The check passes.
	\begin{enumerate} [a.]
	\item An {\bf Asteroid} object is spawned with a random position, movement vector, and rotation speed.
	\item The {\bf Asteroid} careens through space until it hits something or goes too far away.
		\begin{enumerate} [i.]
		\item The {\bf Asteroid} is then destroyed.
		\end{enumerate}
	\end{enumerate}
\end{enumerate}

%%%
\begin{center} \line(1,0){350} \end{center}
Scenario Name: {\bf BulletFizzle} \\
Participating Actor Instances:        \hspace{46pt} {\bf Player: PlayerEntity

					          \hspace{2.6 in}   Bullet: Projectile}  \vspace{10pt}  \\ 
Flow of Events: 
\begin{enumerate} 
\item {\bf Player} shoots a {\bf Bullet}.
\item {\bf Bullet} does not hit anything within the view of the {\bf Player}.
\item {\bf Bullet} travels out of the view of the {\bf Player}.
      \begin{enumerate}[a.]
       \item The {\bf Bullet} collides with an entity
                \begin{enumerate}[i.]
                \item The {\bf Bullet} causes damage to that entity, and terminates itself.
                \end{enumerate}
      \item The {\bf Bullet} does not collide with anything.
                \begin{enumerate}[i.]
                \item The {\bf Bullet} is terminated after a short distance.
                \end{enumerate}
        \end{enumerate}
\end{enumerate}

%%%
\begin{center} \line(1,0){350} \end{center}
Scenario Name: {\bf SpawnPickUp} \\
Participating Actor Instances:        \hspace{46pt} {\bf Player: PlayerEntity
	
						\hspace{2.6 in} Enemy: EnemyEntity

					          \hspace{2.6 in}  Shotgun: PickUp}  \vspace{10pt}  \\ 
Flow of Events: 
\begin{enumerate} 
\item {\bf Player} destroys an {\bf Enemy} with its weapon.
\item {\bf Enemy} rolls a check to see if it drops anything.
\item The check succeeds, and {\bf Enemy} drops a {\bf Shotgun} pickup.
\item {\bf Player} touches the {\bf Shotgun}.
\item The {\bf Shotgun} is equipped, giving {\bf Player} 50 ammo and the {\bf Shotgun} weapon.
\end{enumerate}

%%%
\begin{center} \line(1,0){350} \end{center}
Scenario Name: {\bf PauseGame} \\
Participating Actor Instances:        \hspace{46pt} {\bf Player: PlayerEntity }  \vspace{10pt}  \\ 
Flow of Events: 
\begin{enumerate} 
\item {\bf Player} presses the pause button.
	\begin{enumerate} [a.]
	\item A screen displays over the main screen, informing the {\bf Player} the game is paused.
	\item The game's timescale is set to 0, freezing any objects currently in the scene.
	\end{enumerate}
\item {\bf Player} presses the pause button once more. 
	\begin{enumerate} [a.]
	\item The pause screen is disabled and removed.
	\item The game's timescale is set back to 1, resuming the action.
	\end{enumerate}
\end{enumerate}


\subsection{Use Case Model}
Figure \ref{Use Case Model} shows which external actors participate in each of the Use Case Scenarios included.

\begin{figure} [H]
\centering
\includegraphics[width=5.5in]{UseCaseModel1.png}
\caption{Use Case Model} \label{Use Case Model}
\end{figure}


\section{Design} %DESIGN
\label{sec:Design}

\subsection{Sequence Diagram}
The sequence diagram represented in Figure \ref{PlayerDeath}  corresponds to the use case PlayerDeath, and outlines the process behind the player being hit with a projectile to a death state, followed by the appropriate response by the {\it GameController}. Health will only be subtracted if the player has no remaining shield. If the player no longer has any health or shields after taking damage, then the {\it Player} object will report its death to the {\it GameController}. Sequence diagrams for other use cases are functionally similar, albeit with a few differing actors and method calls.

\begin{figure} [H]
\centering
\includegraphics[width=4.75in]{PlayerDeath.png}
\caption{Player Death Sequence Diagram} \label{PlayerDeath}
\end{figure}

\subsection{UML Diagram}
\hs In Figure \ref{UML} shows the core class design for the game and the relations that classes will have with each other. Classes will be interacting with existing classes of the Unity engine. {\it GameManager} will be a singleton class that will be responsible for holding the {\it Player Entity}, this way the game can easily transport the {\it Player} between scenes without risk of creating a duplicate {\it Player}. {\it GameController} will handle everything that happens inside the level itself, and will be able to do this with the onAwake() function, provided by Unity, that activates when the script has been loaded into the scene. The {\it Entity} object will provide a basis of all entities in-game that will be able to move and react to the game state, including the {\it Player}. The {\it Ship} class will be a prefab handled by Unity that will allow us to instantiate an {\it Entity} object with certain variables from the start. Our {\it Item} and {\it Weapon} interfaces will handle items and weapons picked up in the game, respectively. It is important that there is a distinction between the two, as all {\it Weapons} are {\it Items} but not all {\it Items} are {\it Weapons}.

\begin{figure} [H]
\centering
\includegraphics[width=7.3in]{FinalUMLHorizontal.png}
\caption{UML Diagram} \label{UML}
\end{figure}

\subsection{State Diagram}
Figure \ref{StateDia} describes the transitions between various scenes and menus in the game. Each state corresponds to either a Unity scene or a GUI child menu.

\begin{figure} [H]
\centering
\includegraphics[width=7in]{PewPewStateDiagramFinal.png}
\caption{State Diagram} \label{StateDia}
\end{figure}

{\bf Entity Relationship model: \textcolor{red}{???}}

\hs {\bf Testing plans}: The group members will play the game every step of the way to make sure that the individual additions to the project are functioning as expected. Once there is a version of the game that allows a player to navigate an environment and fight basic enemies, the group will reach out others to play it and give feedback in the form of a simple survey. 

\section{Gameplay Design} %GAMEPLAY DESIGN
\label{sec:GPdesign}

Games are dynamic pieces of software that focus on delivering exciting or interesting experiences to players, gameplay design is as important as backend design. What follows is the basic design for the aspects of the gameplay that the player will see for our current iteration of the game.

\subsection{Player} %Player

	{\bf Player controls: }The player controls a small spaceship, and navigates through a space environment. As seen in Figure \ref{Controls}, the player will move with the WASD keys; pressing a key will cause the ship to rotate to and accelerate in that direction.  Shooting will be controlled by the arrow keys on the keyboard. Pressing an arrow key will cause shots to be fired in that direction. Since movement and shooting are separate, the player may move in one direction and fire in another.  The player can also pause the game with the escape button. The controls are intended to transfer over to a controller relatively easily, so the player may control moving and shooting with the left and right analog stick respectively. The controls diagram is located at Section 5.7 of this document.

	{\bf Player Movement:}	As stated above, the player presses either the WASD keys or the left analog stick to begin rotating and accelerating in that direction. Rotation has a maximum speed, so quickly changing direction causes the ship to veer in a small circle as it rotates to face the intended direction. Acceleration speed will not be instantaneous and the player will not stop automatically, in order to simulate a sense of weight and the lack of friction in space. The ship will perform these actions quickly enough that controlling the ship feels responsive to the player.

	{\bf Player Shooting:} Player shooting functions similarly to player movement in terms of input. By pressing the arrow keys or on the right analog stick, the player will shoot in the respective direction. The player's ship has a rotating gun attached to it, which allow the player to aim and shoot in any direction regardless of current movement. However, there is no rotation time for the gun on the player's ship, so the gun will shoot instantaneously in the direction that is being pressed. Be default the player's ship shoots a rapid fire laser, which will allow the user to get comfortable with shooting without having to worry about missing or wasting ammo. Various weapon pickups can be used to modify how the player's weapon shoots (detailed in Section 5.3). The control method will remain the same for all weapons so the player does not have to worry about learning different controls for each weapon.

	{\bf Player ship:} The players ship will have it’s own health and shield values. The shield will be a rechargeable defense that will be able to absorb a number of shots before the players ship takes permanent health damage. Recharging of the shield will occur over time after a few seconds of avoiding damage. The ship’s health is the amount of damage the ship can sustain before it explodes and the player loses. It will not regenerate automatically like the shield, but items will be able to restore it.

\subsection{Enemies} %Enemies

	\hs {\bf Enemies: } The main goal of enemy ships is to kill the player ship. There are two main strategies the enemies will utilize to accomplish this. Certain enemies will shoot at the player, forcing the player to dodge if they want to survive, while other enemies will attempt to ram the player to deal damage. As such, there are enemy ships that will fly around in basic patterns while shooting at the player, and there are enemy ships that will charge straight at the player to prevent them from staying still for too long. Additionally, there will be “enemy” obstacles such as asteroids that will fly on screen to force players to be aware of their surroundings. These obstacles have no set objective and can hit enemy ships as well.

	The main goal of the enemy ships is to kill the player ship. There are two main types of enemy that employ different tactics to accomplish this goal. The first type of enemy tracks the player while it moves, having the possibility of shooting at a fixed time interval. The second type of enemy will follow the player closely while trying to get in front, having a stronger shot then that of the first enemy, but also firing less frequently. Additionally, there will be “enemy” obstacles such as asteroids that will fly on screen to force players to be aware of their surroundings. These obstacles have no set objective and can hit enemy ships as well.

	{\bf Standard Shooting:}

	{\bf Predictive Shooting:} 

	{\bf Patrolling:}

	{\bf Enemy Type One:}

	{\bf Enemy Type Two:}

	{\bf Bosses:} Bosses will give the player a final challenge before ultimately reaching the end of the game and winning. Bosses will shoot large amounts of projectiles to making dodging difficult for the player. Additionally, the boss will have a predictive shooting projectile to increase the difficulty further. Finally, bosses will have a larger amount of health than the average enemy. Defeating a boss will end the game and display a win screen.

\subsection{Weapons} %Weapons

	{\bf Weapons:} Weapons are implemented through the Unity prefab system. By default, the player is given a low-damage, high rate-of-fire red laser weapon that they can change by finding a weapon pickup which drops off enemies. Once the player makes contact with the pickup, their current weapon is destroyed and the new weapon is loaded for the player. All non-default weapons have a limited amount of ammunition, and once their ammo is depleted, the weapon is destroyed and replaced with the default weapon.

	\begin{enumerate}
	\item {\bf Shotgun:} The shotgun has the same damage and rate of fire as the default weapon. However, every shot of the shotgun fires five bullets in a short, fixed spread, rather than one bullet straight ahead. Has 50 ammo.

	\item {\bf Pulse Gun:} The pulse gun is a high damage, low rate of fire gun that shoots one large pulse of 70 green bullets in the direction the player presses. Bullets fired by this gun do not destroy themselves when colliding with an entity, allowing for a "piercing" effect. Has 10 ammo.

	\item {\bf Minigun:} The minigun has a much faster rate of fire than the default gun. However, its damage is half of the default gun's per shot and the exact direction the bullets will be fired in has a variance, not guaranteeing accuracy. Has 400 ammo.
	\end{enumerate}


\subsection{Levels/Objects} %level

	{\bf Pick-ups:}  There will be pick-ups available to the player throughout the game, dropping from enemies and asteroids. Pick-ups will change some attribute of the player ship, including  speeding the movement of the ship, restoring health, and changing the currently equipped menu.

	{\bf  Items:} The majority of the items in the game will provide a general bonus to the player without requiring additional action from the player. These could include upgrades like increased shield or hull capacity, increased damage, or faster ship acceleration. Additionally, there will be various items that the player can activate by pressing the Activate Item key that will provide the player with some benefit when used. For instance, a time bomb may temporarily slow down enemy ships and projectiles to allow the player to dodge them more easily.

	{\bf Level design:} Enemy placement will play a critical role in the design of levels. The placement of enemies needs to be dense enough so that there is a challenge but  sparce enough so that every level is possible and does not feel the same. Since the game takes place in space, there will not be traditional level elements such as walls and floors. However, there may need to be other obstacles that guide the player‘s movements such as debris or very large ships.

	{\bf Star Field and Background:}

	{\bf Asteroids:} (purpose and spawning)

\subsection{User Interface} % UI

	{\bf Radar:} The radar will be displayed in the bottom left corner. It shows the player the location of all enemies, pick-ups, and asteroids in the immediate surrounding area of the player. In addition, it also represent the direction of all enemies not shown in the immediate area with a symbol on the edge of the radar.

	{\bf HUD:} The player has access to a Heads-Up Display in the bottom right corner, which displays vital information, such as the player's health, shield, currently equipped weapon, ammo remaining, the current wave, the amount of enemies left in the wave, and if the player is currently under the effects of a speed boost, how much time is remaining on their speed boost.

	{\bf Menus:}

\subsection{Art} %Art

	{\bf Story:} The Player is an explorer trying to reach the other side of the Universe to meet aliens that sent a treasure map to earth. The Player keeps in close contact with General Weathersbee who guides them to the last known location of the aliens. 

	{\bf Art/models:} The assets and models used in this project will all be free from the Unity store. We will use our own creativity to make all of the assets blend together in a cohesive way. We are using a black with star background for the main level, and then varying space themed backgrounds for the other scenes. The font Huxely is through out the game to tie the art all together.  

	{\bf Music/ sound:} Sound effects and music will be retrived from the Unity store and other creative commons sites. It will attempt to replicate a space environment similar to other space themed games. For example the laser gun will have a "pew pew pew" sound. 


\subsection{Controls Diagram}

\begin{figure} [H]
\centering
\includegraphics[width=6.3 in]{ControlDiagramFinal.png}
\caption{Controls Diagram} \label{Controls}
\end{figure}


\section{Implementation} %IMPLEMENTATION
\label{sec:history}
This section describes the completed work, current status, and future plans that are to be included to the project.

\subsection{Work Completed}

\hs The Unity website offers in-depth tutorials on how to create basic games using the Unity engine. We have completed two specific tutorials in preparation for this project: The “Beginner” rated project, entitled “Space Shooter”, and the “Intermediate” rated project, “Project: Stealth”.

  The “Space Shooter” tutorial introduced us to the basics of Unity, and explained how to use the engine to create a top-down, two-dimensional space shooter game using given assets, including a three-dimensional ship model, a provided background, and models for asteroids and enemy ships. It also provided sample scripts to use for the completed game, written in $C\#$. The completed project spawned varying waves of asteroids that the player would have to either shoot or dodge, with a score counter incrementing every time the player shot an asteroid and the game ending when the player took damage from colliding with an asteroid and dying.

 The “Project: Stealth” tutorial went into much more depth than the “Space Shooter” tutorial, and guided us through making a fully functional three dimensional stealth-based game. Using provided assets, the tutorial showed us how to use animations to change collisions, enemy AI that reacted to various events that the player had some limited control over, and advanced $C\#$ scripting work that went into more detail than the basics in the “Space Shooter” tutorial. The finished project was a fully functional game in which the player would attempt to reach the end of a level without alerting various AI guards.

  We intend to use many of the elements presented in both of these tutorials as building blocks in our own game. From the “Space Shooter” tutorial we intend to use the fundamental concepts presented in the tutorial, namely scripting, collisions, and two-dimensional top-down shooter action, in our product. From the “Project: Stealth” tutorial we intend to use some of the overall concepts, such as enemy artificial intelligence and events occurring in response to our game state in our product.

\subsection{Current Status}

Development is starting to move out of preliminary stages as we get the group back together for spring semester. We have finished mutiple Unity tutorials and have a basic foundation of the game. We are currently working on creating a new time table to get develpment on track. The design document was completed and turned in on December 18th, 2014, and an updated version of the document was turned in February 19th, 2015. 

\subsection{Future Work}



%\section{Timetable}
%\label{sec:time}
%Figure \ref{Time} describes the planned development cycles for creating the game.

%\begin{figure} [H]
%\centering
%\includegraphics[width=4.3 in]{TimeTableDec.png}
%\caption{Current Time Table} \label{Time}
%\end{figure}


\newpage
%\section{References}
%\label{sec:ref}

\begin{thebibliography}{99}

\bibitem{History} Ringo, D. History of Gaming: A Look at How It All Began. Public Brodcasting Service, n.d. Retrieved October 20, 2014, from PBS: http://www.pbs.org/kcts/videogamerevolution/history. 

\bibitem{Tutorials} Tutorials. Unity Technologies, n.d. Retrieved October 15, 2014, from Unity: http://unity3d.com/learn/tutorials/modules.

\bibitem{C} Creighton, R. Unity 4.x Game Development by Example Beginner's Guide, 3rd ed. Packt Publishing, Birmingham, UK, 2013.

\bibitem{Edgar} Edgar, T. Latex-slides. Department of Mathematics Pacific Lutheran University, Tacoma, WA, September 2011. PDF. 

\bibitem{Rogue} A Brief History of Roguelikes, Kill Screen Daily. Retrieved November 14, 2014 from Kill Screen Daily, INC: http://killscreendaily.com/articles/brief-history-roguelike/.

\bibitem{PCG} Procedural Content Generation Wiki. Retrieved December 4, 2014 from: http://pcg.wikidot.com/.

\bibitem{Cadet} Cadet, H. A Brief History of C Sharp.  N.p., n.d. Retrieved November 13, 2014 from Hernando Cadet Technology:  http://www.hernandocadett.com/content/brief-history-c-sharp/.

\bibitem{E} Elias, H. Perlin Noise. Retrieved December 6, 2014 from: http://freespace.virgin.net/hugo.elias/models/m\_perlin.htm.

\bibitem{Moles} Moles, S. How Does Unity Use $C\#$ as a Scripting Language? N.p., n.d. Retrived: November 13, 2014 from Game Development Stack Exchange: http://gamedev.stackexchange.com/questions/51350/how-does-unity-use-c-as-a-scripting-language.

\bibitem{Ogre} About Object-Oriented Graphics Rendering Engine. Retrived November 2014 from Torus Knot Software: http://www.ogre3d.org/about/

\bibitem{Guide} Stevens, P. and Tenzer J. GUIDE: Games with UML for Interactive Design Exploration. 
{ \it Laboratory for Foundations of Computer Science School of Informatics}. Retrived November 16, 2014 from University of Edinburgh: http://homepages.inf.ed.ac.uk/perdita/guide.pdf.

\bibitem{UML} UML for games. November 2003. Retrived November 16, 2014 from GameDev.Net LLC: http://www.gamedev.net/topic/192120-uml-for-games/

\bibitem{A} Patel, A. Introduction to A*. Red Blob Games, 1997. Retrived November 18, 2014 from Stanford University: http://theory.stanford.edu/~amitp/GameProgramming.
 
\bibitem{GDD} Effectively Organize Your Game's Development With a Game Design Document. Tutsplus. Gamux. Envato, November 11, 2011. Retrived November 18, 2014 from Tutsplus: http://code.tutsplus.com/articles/effectively-organize-your-games-development-with-a-game-design-document--active-10140. 


\end{thebibliography}

\newpage

\section{Glossary}
\label{sec:gloss}

{\bf{AI}} - Artificial Intelligence, in our case directing the actions of the NPCs. \\
{\bf Boss} - A unique hostile entity that appears at the end of a level. \\
{\bf Entity} - An object that can interact with other objects in the game. \\
{\bf Field of Play} - The area in which a player will interact with obstacles, enemies, and other events. \\
{\bf HP} - Health points, a measure of the players health level often represented as either a fraction or bar. \\
{\bf Level} - A collection of similarly challenging fields of play culminating in a boss. \\
{\bf NPC} - Non Player Characters, e.g., any enemies or passive characters that act in the game that are not controlled by the player. \\
{\bf Parallax} - The effect whereby the position or direction of an object appears to differ when viewed from different positions, e.g., elements far from the camera appear to move more slowly than foreground elements. \\
{\bf Prefab} - A function supported by Unity that allows for predefined object specification and quick entity instantiation. \\
{\bf Ramming} - When one entity attacks another through direct collision. \\
{\bf Roguelike Game} - A game that is distinct because of two important characteristics:
Has highly randomized gameplay with a large amount of replayability. 
Permanent death, meaning if the main protagonist dies, the game ends and the player must restart from the beginning. \\
{\bf Sprite} - The image that represents entities in the game. \\
{\bf Unity} - The primary game engine we will be using. \\
{\bf Unity3D} - The software kit used to develop games in Unity. \\
{\bf Usable Items} - Items the player can use by pressing the use item key. \\



\end{document}



